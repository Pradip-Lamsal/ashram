-- Backend Database Improvements for Ashram Management System
-- Run this in Supabase SQL Editor to implement all improvements

-- ===================================
-- STEP 1: Verify Nepali Date Columns (Already Present!)
-- ===================================

-- Your donations table already has these columns - just adding comments for clarity
COMMENT ON COLUMN public.donations.start_date_nepali IS 'Start date in Nepali format (YYYY/MM/DD) for Seva Donation periods';
COMMENT ON COLUMN public.donations.end_date_nepali IS 'End date in Nepali format (YYYY/MM/DD) for Seva Donation periods';

-- Verify the columns exist and show their current state
SELECT 
    column_name, 
    data_type, 
    is_nullable,
    column_default
FROM information_schema.columns 
WHERE table_name = 'donations' 
  AND table_schema = 'public'
  AND column_name IN ('start_date_nepali', 'end_date_nepali');

-- ===================================
-- STEP 2: Optimize Database Functions
-- ===================================

-- Create atomic donation+receipt creation function
CREATE OR REPLACE FUNCTION create_donation_with_receipt(
    p_donor_id UUID,
    p_donation_type TEXT,
    p_amount NUMERIC(10,2),
    p_payment_mode TEXT,
    p_date_of_donation DATE DEFAULT CURRENT_DATE,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_start_date_nepali VARCHAR(12) DEFAULT NULL,
    p_end_date_nepali VARCHAR(12) DEFAULT NULL,
    p_notes TEXT DEFAULT NULL,
    p_created_by UUID DEFAULT NULL
) RETURNS JSON AS $$
DECLARE
    v_donation_id UUID;
    v_receipt_id UUID;
    v_receipt_number TEXT;
    result JSON;
BEGIN
    -- Start transaction (implicit in function)
    
    -- Create donation
    INSERT INTO public.donations (
        donor_id, donation_type, amount, payment_mode, 
        date_of_donation, start_date, end_date,
        start_date_nepali, end_date_nepali, notes, created_by
    ) VALUES (
        p_donor_id, p_donation_type, p_amount, p_payment_mode,
        p_date_of_donation, p_start_date, p_end_date,
        p_start_date_nepali, p_end_date_nepali, p_notes, p_created_by
    ) RETURNING id INTO v_donation_id;
    
    -- Create receipt (receipt number auto-generated by trigger)
    INSERT INTO public.receipts (donation_id, issued_at)
    VALUES (v_donation_id, NOW())
    RETURNING id, receipt_number INTO v_receipt_id, v_receipt_number;
    
    -- Return combined result
    SELECT json_build_object(
        'donation_id', v_donation_id,
        'receipt_id', v_receipt_id,
        'receipt_number', v_receipt_number,
        'success', true
    ) INTO result;
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Rollback happens automatically
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===================================
-- STEP 3: Create Optimized View for Receipts
-- ===================================

-- Create materialized view for better performance
CREATE OR REPLACE VIEW receipt_details_view AS
SELECT 
    r.id as receipt_id,
    r.receipt_number,
    r.issued_at,
    r.is_printed,
    r.is_email_sent,
    r.created_at as receipt_created_at,
    
    -- Donation details
    d.id as donation_id,
    d.donation_type,
    d.amount,
    d.payment_mode,
    d.date_of_donation,
    d.start_date,
    d.end_date,
    d.start_date_nepali,
    d.end_date_nepali,
    d.notes as donation_notes,
    d.created_at as donation_created_at,
    
    -- Donor details
    dr.id as donor_id,
    dr.name as donor_name,
    dr.email as donor_email,
    dr.phone as donor_phone,
    dr.address as donor_address,
    dr.donation_type as donor_default_donation_type,
    dr.membership as donor_membership,
    dr.total_donations as donor_total_donations,
    dr.last_donation_date as donor_last_donation_date
    
FROM public.receipts r
JOIN public.donations d ON r.donation_id = d.id
JOIN public.donors dr ON d.donor_id = dr.id
WHERE r.deleted_at IS NULL 
  AND d.deleted_at IS NULL 
  AND dr.deleted_at IS NULL;

-- ===================================
-- STEP 4: Add Performance Indexes
-- ===================================

-- Composite indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_donations_donor_date 
ON public.donations(donor_id, date_of_donation DESC) 
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_receipts_donation_number 
ON public.receipts(donation_id, receipt_number) 
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_donations_type_date 
ON public.donations(donation_type, date_of_donation DESC) 
WHERE deleted_at IS NULL;

-- Full-text search indexes for names and emails
CREATE INDEX IF NOT EXISTS idx_donors_name_search 
ON public.donors USING gin(to_tsvector('english', name)) 
WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_donors_email_search 
ON public.donors USING gin(to_tsvector('english', COALESCE(email, ''))) 
WHERE deleted_at IS NULL;

-- ===================================
-- STEP 5: Optimize Donor Stats Update Function
-- ===================================

-- More efficient donor stats update (called by trigger)
CREATE OR REPLACE FUNCTION update_donor_totals_optimized()
RETURNS TRIGGER AS $$
BEGIN
    -- Only update if it's a new donation or amount changed
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.amount != NEW.amount) THEN
        UPDATE public.donors
        SET 
            total_donations = (
                SELECT COALESCE(SUM(amount), 0)
                FROM public.donations
                WHERE donor_id = NEW.donor_id AND deleted_at IS NULL
            ),
            last_donation_date = (
                SELECT MAX(date_of_donation)
                FROM public.donations
                WHERE donor_id = NEW.donor_id AND deleted_at IS NULL
            ),
            updated_at = NOW()
        WHERE id = NEW.donor_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Replace existing trigger with optimized version
DROP TRIGGER IF EXISTS trigger_update_donor_totals ON public.donations;
CREATE TRIGGER trigger_update_donor_totals_optimized
    AFTER INSERT OR UPDATE OF amount ON public.donations
    FOR EACH ROW
    EXECUTE FUNCTION update_donor_totals_optimized();

-- ===================================
-- STEP 6: Add Data Validation Functions
-- ===================================

-- Function to validate Nepali date format
CREATE OR REPLACE FUNCTION is_valid_nepali_date(date_str TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- Check if format matches YYYY/MM/DD or YYYY-MM-DD
    -- Support both ASCII numerals (2082/01/01) and Devanagari numerals (२०८२-०१-०१)
    -- Also allow NULL values
    RETURN date_str IS NULL 
        OR date_str ~ '^[0-9]{4}[/-][0-9]{1,2}[/-][0-9]{1,2}$'
        OR date_str ~ '^[०-९]{4}[-/][०-९]{1,2}[-/][०-९]{1,2}$';
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- First, let's check what invalid data exists
SELECT 
    id,
    start_date_nepali,
    end_date_nepali,
    is_valid_nepali_date(start_date_nepali) as start_valid,
    is_valid_nepali_date(end_date_nepali) as end_valid
FROM public.donations 
WHERE NOT is_valid_nepali_date(start_date_nepali) 
   OR NOT is_valid_nepali_date(end_date_nepali);

-- Clean up invalid Nepali date formats
-- Convert any invalid formats to NULL (they can be regenerated from English dates)
UPDATE public.donations 
SET start_date_nepali = NULL 
WHERE NOT is_valid_nepali_date(start_date_nepali);

UPDATE public.donations 
SET end_date_nepali = NULL 
WHERE NOT is_valid_nepali_date(end_date_nepali);

-- Now add the constraints (they should work since we cleaned the data)
ALTER TABLE public.donations 
ADD CONSTRAINT check_nepali_start_date 
CHECK (start_date_nepali IS NULL 
    OR start_date_nepali ~ '^[0-9]{4}[/-][0-9]{1,2}[/-][0-9]{1,2}$'
    OR start_date_nepali ~ '^[०-९]{4}[-/][०-९]{1,2}[-/][०-९]{1,2}$');

ALTER TABLE public.donations 
ADD CONSTRAINT check_nepali_end_date 
CHECK (end_date_nepali IS NULL 
    OR end_date_nepali ~ '^[0-9]{4}[/-][0-9]{1,2}[/-][0-9]{1,2}$'
    OR end_date_nepali ~ '^[०-९]{4}[-/][०-९]{1,2}[-/][०-९]{1,2}$');

-- ===================================
-- STEP 7: Create Efficient Statistics Function
-- ===================================

-- Fast dashboard statistics function
CREATE OR REPLACE FUNCTION get_dashboard_stats()
RETURNS JSON AS $$
DECLARE
    stats JSON;
BEGIN
    SELECT json_build_object(
        'total_donors', (SELECT COUNT(*) FROM public.donors WHERE deleted_at IS NULL),
        'total_donations', (SELECT COUNT(*) FROM public.donations WHERE deleted_at IS NULL),
        'total_receipts', (SELECT COUNT(*) FROM public.receipts WHERE deleted_at IS NULL),
        'total_amount', (SELECT COALESCE(SUM(amount), 0) FROM public.donations WHERE deleted_at IS NULL),
        'this_month_donations', (
            SELECT COUNT(*) FROM public.donations 
            WHERE deleted_at IS NULL 
            AND date_of_donation >= date_trunc('month', CURRENT_DATE)
        ),
        'this_month_amount', (
            SELECT COALESCE(SUM(amount), 0) FROM public.donations 
            WHERE deleted_at IS NULL 
            AND date_of_donation >= date_trunc('month', CURRENT_DATE)
        ),
        'payment_mode_stats', (
            SELECT json_object_agg(payment_mode, count)
            FROM (
                SELECT payment_mode, COUNT(*) as count
                FROM public.donations 
                WHERE deleted_at IS NULL
                GROUP BY payment_mode
            ) pm
        ),
        'top_donors', (
            SELECT json_agg(
                json_build_object(
                    'id', id,
                    'name', name,
                    'total_donations', total_donations
                )
            )
            FROM (
                SELECT id, name, total_donations
                FROM public.donors 
                WHERE deleted_at IS NULL 
                ORDER BY total_donations DESC 
                LIMIT 5
            ) top
        )
    ) INTO stats;
    
    RETURN stats;
END;
$$ LANGUAGE plpgsql;

-- ===================================
-- STEP 8: Add Row Level Security Improvements
-- ===================================

-- More granular RLS policies
DROP POLICY IF EXISTS "Users can view all receipts" ON public.receipts;
DROP POLICY IF EXISTS "Users can insert receipts" ON public.receipts;
DROP POLICY IF EXISTS "Users can update receipts" ON public.receipts;

-- Create better RLS policies
CREATE POLICY "Authenticated users can view receipts"
ON public.receipts FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Authenticated users can create receipts"
ON public.receipts FOR INSERT
TO authenticated
WITH CHECK (true);

CREATE POLICY "Users can update own receipts"
ON public.receipts FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.donations d
        WHERE d.id = donation_id 
        AND d.created_by = auth.uid()
    )
);

-- ===================================
-- SUCCESS MESSAGE
-- ===================================

SELECT 'Backend improvements applied successfully!' as result,
       'Added Nepali date columns, optimized functions, and improved performance' as details;